<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Atomic Kotlin: Hashing</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="atomickotlin-html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
  <a href="http://AtomicKotlin.com/sample/">
    <img src="Banner.png" alt="Table of Contents" class="banner-image">
  </a>
</header>
<h1 id="hashing">Hashing</h1>
<blockquote>
<p><strong>This Atom is Under Construction</strong></p>
</blockquote>
<blockquote>
<p>Throughout this book you’ve been introduced to the most commonly-used collections, also called <em>containers</em>.</p>
</blockquote>
<p>These include <code>List</code>s (a specific version of the general concept of the <em>sequence</em>), and <code>Map</code>s (sometimes called <em>associative arrays</em>, because they associate keys with values). There’s a third collection which is used somewhat less often, the <code>Set</code>, which determines membership—is something in a <code>Set</code> or isn’t it? A <code>Set</code> also has the quality that it only allows one of each element, so it is often used to remove duplicates.</p>
<p>What we haven’t emphasized is that <code>List</code>s, <code>Map</code>s and <code>Set</code>s are interfaces that have multiple implementations. The reason for these multiple implementations is that you use collections in different situations. Sometimes you’ll create a collection, and then only read from that collection and never add new elements. In other situations you’ll constantly be adding new elements. <em>How</em> you add those elements is also important. For example, with some implementations of <code>List</code>, adding elements at the end is very fast but putting them in the middle is much slower, while for other implementations it’s much less expensive to put elements in the middle.</p>
<p><strong>End of sample. See <a href="http://atomickotlin.com/earlyaccess/">AtomicKotlin.com</a> for full early-access book.</strong></p>
<br><br><a href="078_Immutability.html">Previous</a>          <a href="080_Operator_Overloading.html">Next</a><br>
<p class="copy">
©2018 <a href="http://mindviewllc.com/">Mindview LLC</a>. All Rights Reserved.
</p>
<p><br><br></p>
</body>
</html>
