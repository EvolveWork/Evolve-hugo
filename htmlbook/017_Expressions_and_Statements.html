<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Atomic Kotlin: Expressions_and_Statements</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="atomickotlin-html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
  <a href="http://AtomicKotlin.com/sample/">
    <img src="Banner.png" alt="Table of Contents" class="banner-image">
  </a>
</header>
<h1 id="expressions-statements">Expressions &amp; Statements</h1>
<blockquote>
<p>The smallest useful fragment of code in many programming languages is either a <em>statement</em> or an <em>expression</em>.</p>
</blockquote>
<p>There’s one simple difference: a statement has an effect, but produces no result. An expression always produces a result.</p>
<p>Because it doesn’t produce a result, a statement must change the state of its surroundings in order to be useful. Another way to say this is “a statement is called for its <em>side effects</em>” (that is, what it does <em>other</em> than producing a result). As a memory aid:</p>
<blockquote>
<p>A statement changes state</p>
</blockquote>
<p>One definition of “express” is “to force or squeeze out,” as in “to express the juice from an orange.” So</p>
<blockquote>
<p>An expression expresses</p>
</blockquote>
<p>That is, it produces a result.</p>
<p>The <code>for</code> loop is a statement in Kotlin, so you cannot assign it, since there’s no result:</p>
<div class="sourceCode" id="cb1"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">// ExpressionsStatements/ForIsAStatement.kt</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="co">// Can&#39;t do this:</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="co">// val f = for(i in 1..10) {}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="co">// Compiler error message:</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="co">// for is not an expression, and</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="co">// only expressions are allowed here</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">}</a></code></div>
<p>A <code>for</code> loop is called for its side effects.</p>
<p>An expression produces a value, which can be assigned or used as part of another expression, whereas a statement is always a top-level element.</p>
<p>Every function call is an expression. Even if the function has the <code>Unit</code> return type and is called only for its side effects, the result can still be assigned. <code>Unit</code> is a legitimate return value, so a function producing <code>Unit</code> is an expression:</p>
<div class="sourceCode" id="cb2"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// ExpressionsStatements/UnitReturnType.kt</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">unitFun</span>() = <span class="kw">Unit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  println(unitFun())</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">val</span> <span class="va">u1</span>: <span class="kw">Unit</span> = println(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  println(u1)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="kw">val</span> <span class="va">u2</span> = println(<span class="dv">0</span>) <span class="co">// Type inference</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  println(u2)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">/* Output:</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="co">kotlin.Unit</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="co">42</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="co">kotlin.Unit</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="co">0</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="co">kotlin.Unit</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="co">*/</span></a></code></div>
<p>The <code>Unit</code> type contains a single value called <code>Unit</code>, which you can return directly, as seen in <code>unitFun()</code>. <code>println()</code> also returns <code>Unit</code>. <code>u1</code> captures the return value of <code>println()</code> and is explicitly declared as <code>Unit</code> while <code>u2</code> uses type inference.</p>
<p>Because <code>if</code> creates an expression, its result can be assigned:</p>
<div class="sourceCode" id="cb3"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">// ExpressionsStatements/AssigningAnIf.kt</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">val</span> <span class="va">result1</span> = <span class="cf">if</span> (<span class="dv">11</span> &gt; <span class="dv">42</span>) <span class="dv">9</span> <span class="cf">else</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="kw">val</span> <span class="va">result2</span> = <span class="cf">if</span> (<span class="dv">1</span> &lt; <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">val</span> <span class="va">a</span> = <span class="dv">11</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    a + <span class="dv">42</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  } <span class="cf">else</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  <span class="kw">val</span> <span class="va">result3</span> =</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="cf">if</span> (<span class="ch">&#39;x&#39;</span> &lt; <span class="ch">&#39;y&#39;</span>)</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">      println(<span class="st">&quot;x &lt; y&quot;</span>)</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">      println(<span class="st">&quot;x &gt; y&quot;</span>)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  println(result1)</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  println(result2)</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  println(result3)</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">}</a>
<a class="sourceLine" id="cb3-21" data-line-number="21"><span class="co">/* Output:</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22"><span class="co">x &lt; y</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="co">5</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24"><span class="co">53</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25"><span class="co">kotlin.Unit</span></a>
<a class="sourceLine" id="cb3-26" data-line-number="26"><span class="co">*/</span></a></code></div>
<p>The first output line is <code>x &lt; y</code>, even though <code>result3</code> isn’t displayed until the end of <code>main()</code>. This happens because evaluating <code>result3</code> calls <code>println()</code>, and the evaluation happens when <code>result3</code> is defined.</p>
<p>Notice that <code>a</code> is defined inside the block of code for <code>result2</code>. The result of the last expression becomes the result of the <code>if</code> expression; here, its the sum of 11 and 42. But what about <code>a</code>? Once you leave the block of the code (move outside the curly braces), you can’t access <code>a</code>. It is <em>temporary</em> and is discarded once you exit the <em>scope</em> of the block.</p>
<p>The increment operator <code>i++</code> is also an expression, even if it looks like a statement. Kotlin follows the approach used by C-like languages and provides two versions of increment and decrement operators with slightly different semantics. The prefix operator is put before the operand, as in <code>++i</code>, and returns the value after the increment happens. You can read it as “first do the increment, then return the resulting value.” The postfix operator is put after the operand, as in <code>i++</code>, and returns the value of <code>i</code> before the increment occurs. You can read it as “first produce the result, then do the increment.”</p>
<div class="sourceCode" id="cb4"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">// ExpressionsStatements/PostfixVsPrefix.kt</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">var</span> <span class="va">i</span> = <span class="dv">10</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  println(i++)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  println(i)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="kw">var</span> <span class="va">j</span> = <span class="dv">20</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  println(++j)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  println(j)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="co">/* Output:</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="co">10</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="co">11</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"><span class="co">21</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="co">21</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="co">*/</span></a></code></div>
<p>The decrement operator similarly has two versions: <code>--i</code> and <code>i--</code>. Using these operators within other expressions is discouraged because it can produce confusing code:</p>
<div class="sourceCode" id="cb5"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">// ExpressionsStatements/ConfusingOperator.kt</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">var</span> <span class="va">i</span> = <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  println(i++ + ++i)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">}</a></code></div>
Try to guess what the output will be, then check it. <br><br><a href="016_The_in_Keyword.html">Previous</a>          <a href="018_Summary_1.html">Next</a><br>
<p class="copy">
©2018 <a href="http://mindviewllc.com/">Mindview LLC</a>. All Rights Reserved.
</p>
<p><br><br></p>
</body>
</html>
