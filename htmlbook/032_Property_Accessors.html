<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Atomic Kotlin: Property_Accessors</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="atomickotlin-html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
  <a href="http://AtomicKotlin.com/sample/">
    <img src="Banner.png" alt="Table of Contents" class="banner-image">
  </a>
</header>
<h1 id="property-accessors">Property Accessors</h1>
<blockquote>
<p>To read a property, simply refer to its name. To assign a value to a mutable property, use the assignment operator <code>=</code>.</p>
</blockquote>
<p>Here, we read and write the property <code>i</code>:</p>
<div class="sourceCode" id="cb1"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">// PropertyAccessors/Data.kt</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">package</span> <span class="im">propertyaccessors</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">class</span> Data(<span class="kw">var</span> <span class="va">i</span>: <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">fun</span> main(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="kw">val</span> <span class="va">data</span> = Data(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="kw">data</span>.i eq <span class="dv">10</span> <span class="co">// Read the &#39;i&#39; property</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="kw">data</span>.i = <span class="dv">20</span>  <span class="co">// Write to the &#39;i&#39; property</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">}</a></code></div>
<p>Although this looks like straightforward access to the piece of storage named <code>i</code>, the compiler is actually calling functions to perform the read and write operations. The default behavior of those functions is to simply read and write the data stored in <code>i</code>. In this atom you’ll learn to write your own <em>property accessors</em> which change the actions that occur during reading and writing.</p>
<p>The accessor used to get the value of a property is called a <em>getter</em>; you create your own getter by defining <code>get()</code>, directly after the property declaration. The accessor used to modify a mutable property is called a <em>setter</em>; you create your own setter by defining <code>set()</code>, directly after the property declaration.</p>
<p>The property accessors defined in the following example imitate the default implementations generated by the compiler, displaying additional information so you can see that the property accessors are indeed called during reads and writes. We indent the <code>get()</code> and <code>set()</code> functions to visually associate them with the property, but the actual association happens because they are defined directly after that property:</p>
<div class="sourceCode" id="cb2"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// PropertyAccessors/Default.kt</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">class</span> Default {</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">var</span> <span class="va">i</span>: <span class="kw">Int</span> = <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="kw">get</span>() {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      println(<span class="st">&quot;get()&quot;</span>)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">return</span> field         <span class="co">// [1]</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    <span class="kw">set</span>(value) {</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      println(<span class="st">&quot;set($value)&quot;</span>)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">      field = value        <span class="co">// [2]</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  <span class="kw">val</span> <span class="va">d</span> = Default()</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  d.i = <span class="dv">2</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  println(d.i)</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb2-20" data-line-number="20"><span class="co">/* Output:</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"><span class="co">set(2)</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22"><span class="co">get()</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23"><span class="co">2</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="co">*/</span></a></code></div>
<p>The definition order for <code>get()</code> and <code>set()</code> is unimportant. You can define <code>get()</code> without defining <code>set()</code>, and vice-versa.</p>
<p>The default behavior for a property is to return its stored value from a getter and modify it with a setter—the actions of <strong>[1]</strong> and <strong>[2]</strong>. Inside the getter and setter, the stored value is manipulated indirectly using the <code>field</code> keyword, which is only accessible within these two functions.</p>
<p>Here’s an example that uses the default implementation of the getter, but adds a setter that traces changes to the property <code>n</code>:</p>
<div class="sourceCode" id="cb3"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">// PropertyAccessors/LogChanges.kt</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">class</span> LogChanges {</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="kw">var</span> <span class="va">n</span>: <span class="kw">Int</span> = <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">set</span>(value) {</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      println(<span class="st">&quot;$field becomes $value&quot;</span>)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      field = value</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  <span class="kw">val</span> <span class="va">lc</span> = LogChanges()</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  lc.n eq <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  lc.n = <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  lc.n eq <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="co">/* Output:</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"><span class="co">0</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20"><span class="co">0 becomes 2</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21"><span class="co">2</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22"><span class="co">*/</span></a></code></div>
<p>If you declare a <code>private</code> property, both accessors become <code>private</code>. You can make the setter <code>private</code> and the getter <code>public</code>. Then you can read the property outside the class, but only change its value inside the class:</p>
<div class="sourceCode" id="cb4"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">// PropertyAccessors/Counter.kt</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">package</span> <span class="im">propertyaccessors</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">class</span> Counter {</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">var</span> <span class="va">value</span>: <span class="kw">Int</span> = <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="kw">private</span> <span class="kw">set</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="kw">fun</span> <span class="fu">inc</span>() = value++</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  <span class="kw">val</span> <span class="va">counter</span> = Counter()</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  repeat(<span class="dv">10</span>) {</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    counter.inc()</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  counter.value eq <span class="dv">10</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">}</a></code></div>
<p>Using <code>private set</code>, we control the <code>value</code> property so it can only be incremented by one.</p>
<p>Most properties use the typical approach of storing the data in a field. You can also create a property that doesn’t have a field:</p>
<div class="sourceCode" id="cb5"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">// PropertyAccessors/Hamsters.kt</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">package</span> <span class="im">propertyaccessors</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">class</span> Hamster(<span class="kw">val</span> <span class="va">name</span>: <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">class</span> Cage(<span class="kw">private</span> <span class="kw">val</span> <span class="va">maxCapacity</span>: <span class="dt">Int</span>) {</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  <span class="kw">private</span> <span class="kw">val</span> <span class="va">hamsters</span> =</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    mutableListOf&lt;Hamster&gt;()</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">val</span> <span class="va">capacity</span>: <span class="kw">Int</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="kw">get</span>() = maxCapacity - hamsters.size</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  <span class="kw">val</span> <span class="va">full</span>: <span class="kw">Boolean</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="kw">get</span>() = hamsters.size == maxCapacity</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  <span class="kw">fun</span> <span class="fu">put</span>(<span class="va">hamster</span>: <span class="dt">Hamster</span>): <span class="dt">Boolean</span> =</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    <span class="cf">if</span> (full)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">      <span class="kw">false</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">      hamsters += hamster</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">      <span class="kw">true</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">  <span class="kw">fun</span> <span class="fu">takeHamster</span>(): <span class="dt">Hamster</span> =</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    hamsters.removeAt(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">  <span class="kw">val</span> <span class="va">cage</span> = Cage(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-27" data-line-number="27">  cage.full eq <span class="kw">false</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">  cage.capacity eq <span class="dv">2</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">  cage.put(Hamster(<span class="st">&quot;Alice&quot;</span>)) eq <span class="kw">true</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30">  cage.put(Hamster(<span class="st">&quot;Bob&quot;</span>)) eq <span class="kw">true</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">  cage.full eq <span class="kw">true</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32">  cage.capacity eq <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-33" data-line-number="33">  cage.put(Hamster(<span class="st">&quot;Charlie&quot;</span>)) eq <span class="kw">false</span></a>
<a class="sourceLine" id="cb5-34" data-line-number="34">  cage.takeHamster()</a>
<a class="sourceLine" id="cb5-35" data-line-number="35">  cage.capacity eq <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-36" data-line-number="36">}</a></code></div>
<p>The properties <code>capacity</code> and <code>full</code> contain no underlying state—they are computed at the time of each access. Both <code>capacity</code> and <code>full</code> are similar to functions, and you can alternatively define them as such:</p>
<div class="sourceCode" id="cb6"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">// PropertyAccessors/Hamsters2.kt</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">package</span> <span class="im">propertyaccessors</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">class</span> Cage2(<span class="kw">private</span> <span class="kw">val</span> <span class="va">maxCapacity</span>: <span class="dt">Int</span>) {</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">private</span> <span class="kw">val</span> <span class="va">hamsters</span> =</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    mutableListOf&lt;Hamster&gt;()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="kw">fun</span> <span class="fu">getCapacity</span>(): <span class="dt">Int</span> =</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    maxCapacity - hamsters.size</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">fun</span> <span class="fu">isFull</span>(): <span class="dt">Boolean</span> =</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    hamsters.size == maxCapacity</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">}</a></code></div>
<p>In this case, creating them as properties improves readability, because capacity and fullness are properties of the cage. However, don’t just convert all your functions to properties—first, see how they read. The Kotlin style guide prefers properties over functions when the value is cheap to calculate and the property returns the same result between invocations if the object state hasn’t changed.</p>
Notice that property accessors provide a kind of protection for properties. Many object-oriented languages rely on making a physical field <code>private</code> in order to control access to that property. With property accessors you can add code to control or modify that access, while still allowing anyone to use a property. <br><br><a href="031_Maps.html">Previous</a>          <a href="033_Summary_2.html">Next</a><br>
<p class="copy">
©2018 <a href="http://mindviewllc.com/">Mindview LLC</a>. All Rights Reserved.
</p>
<p><br><br></p>
</body>
</html>
